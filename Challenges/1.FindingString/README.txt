Challenge 1: To use Ghidra, you first need to have a basic understanding of assembly. When you compile a program, your assembler takes your written code and converts it into a series of instructions for a processor. Different processor architectures use different machine instructions (or "opcodes"), which operate on some number of bits, generally to either move or change the bits in some way. Different compilers can have different methods for breaking your code into opcodes, which means that the process of compiling a program is not reversible. What a decompiler like Ghidra does is look at the raw binary of a program, try to determine what processor architecture the code is meant to run on, and then attempt to map the binary in the program to the opcodes of a processor to produce assembly code. Ghidra is a free tool for doing this, which is produced (and used) by the National Security Agency (NSA). To get started, download Ghidra and get it working (this may take some doing!), then create a new project and import <LINK HERE> this file. When you import this file, Ghidra likely won't automatically identify the processor, because we've stripped most of the file contents to make the assembly easier to understand. Specify that the Language was compiled for a 64-bit x86 processor by gcc. All binaries for this quest line will be 64-bit x86 gcc, so you should probably have an instruction list handy (https://en.wikipedia.org/wiki/X86_instruction_listings). Remember that reverse engineering is about targeted understanding, not total understanding, so don't waste time reading that page, just be prepared to reference it as necessary to complete the task at hand. Once you specify the language, Ghidra will load the file and display a summary, which we'll cover in more detail in a later exercise. When you double click on the file, or click on the image of Ghidra (looks like a green dragon), it should pull up a new window and ask you if you want to analyze the code. You would! Scroll through all the different options to see what's there, but for now just use the defaults and click Analyze. <Now walk them through some assembly, talking about opcode and operands, and how the command for instance Moves the last operand byte TO the first operand byte>
Let's try to get a basic understanding of x86-64 assembly. Here is an assembly command:
MOV	RDI, 0x6
In this command, the value 0x6 (6) is MOVed into the register named RDI. This is the format of all x86-64 assembly. The first value is altered by the second value. Let's look at another example.
MOV	RSI, 0x10
ADD	RSI, 0x4
In this command, the value 0x10 (16) is MOVed into the register named RSI. Then, 0x4 (4) is ADDed to the value stored in RSI, giving us the value 0x14 (20) being stored in RSI.
In all of the above, the opcode is given first (MOV or ADD, in this case), and the operands are all that follows (RDI, RSI, 0x6, 0x10, and 0x4, respectively).

In this challenge, the user is to decompile a string (c char array, in this case) from the given simple program. The program has been compiled with gcc on an x86-64 bit little-endian system, which will need to be manually entered into Ghidra due to the program being stripped to only its vital bytes.
Answer: My Queen


Challenge 7: <Now let's have them modify the binary to unlock the functionality. The functionality should be complex enough that it would be time consuming to analyze statically> Having used Ghidra to identify where the hidden functionality is located, let's restore it. For this quest, you'll need to use Ghidra to identify an address, and then use a hex editor to modify that address. In the previous exercise, you found that the hidden functionality requires an unprintable hex value to be entered. There are different ways of dynamically accessing this functionality, but for this exercise, try to modify the hex value to an ASCII value of your choice (always edit a copy of your binary, not the original!). Now when you run the program, you can enter this ASCII value to get the program to execute the "hidden" path. For large programs, you will be able to reverse engineer functionality much more quickly when you use a combination of static (Ghidra) and dynamic (execute the binary, usually in a VM or sandbox) analysis. What is the value printed to the user after the string that indicates the hidden functionality is executing? <doesn't matter. Throw a ton of stuff at it: AES, relying on memory values to compute output, etc.. So long as it is repeatable.>
Challenge 8: Buffer overflow that loses data, require user to brute force the missing/lost byte?
Challenge 9: <For this to work for DC Darknet, the last few challenges should be really hard. We should probably unleash the people on a file that occurs in the wild, but we'll need to modify a byte somewhere so they can't just match a hash of the file to a known value, how about a Calculator program? Do we also need to append NOPs in various places to change the size? We'll definitely need to scrub any strings in all of the following.> What is this program?
Challenge 10: <Same thing, should be very hard. How about a lightweight web browser? Midori?> What is this program?
Challenge 11: <We don't want to give them anything bigger than a megabyte, because that would probably take a full day at least to understand. What about a lightweight word processor? Abiword?> What is this program?
Challenge 12: <Last challenge should be different, unique. Can you analyze Ghidra with Ghidra?> What is this program?


We're probably going to be good with ~10-20 challenges.
<Feel free to change any of these. I just find it helpful to plan out what I'm going to do so I can understand what my final objective is, and what I need to teach along the way for people to understand it.>

