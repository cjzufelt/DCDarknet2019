In this challenge, the user is to decompile a string (c char array, in this case) from the given simple program. The program has been compiled with gcc on an x86-64 bit little-endian system, which will need to be manually entered into Ghidra due to the program being stripped to only its vital bytes.
Answer: My Queen
XOR this with 5A to get 0x17237A0B2F3F3F34
Challenge 1: To use Ghidra, you first need to have a basic understanding of assembly. When you compile a program, your assembler takes your written code and converts it into a series of instructions for a processor. Different processor architectures use different machine instructions (or "opcodes"), which operate on some number of bits, generally to either move or change the bits in some way. Different compilers can have different methods for breaking your code into opcodes, which means that the process of compiling a program is not reversible. What a decompiler like Ghidra does is look at the raw binary of a program, try to determine what processor architecture the code is meant to run on, and then attempt to map the binary in the program to the opcodes of a processor to produce assembly code. Ghidra is a free tool for doing this, which is produced (and used) by the National Security Agency (NSA). To get started, download Ghidra and get it working (this may take some doing!), then create a new project and import <link here> this file. When you import this file, Ghidra likely won't automatically identify the processor, because we've stripped most of the file contents to make the assembly easier to understand. Specify that the Language was compiled for a 64-bit x86 processor by gcc. All binaries for this quest line will be 64-bit x86 gcc, so you should probably have an instruction list handy (https://en.wikipedia.org/wiki/X86_instruction_listings). Remember that reverse engineering is about targeted understanding, not total understanding, so don't waste time reading that page, just be prepared to reference it as necessary to complete the task at hand. Once you specify the language, Ghidra will load the file and display a summary, which we'll cover in more detail in a later exercise. When you double click on the file, or click on the image of Ghidra (looks like a green dragon), it should pull up a new window and ask you if you want to analyze the code. You would! Scroll through all the different options to see what's there, but for now just use the defaults and click Analyze. <Now walk them through some assembly, talking about opcode and operands, and how the command for instance Moves the last operand byte TO the first operand byte> <Find string address?>
Challenge 2: Congrats! You've now used the same tool that the NSA uses, and solved <blah>! Now instead of just finding an address, let's try to use Ghidra to understand what some code is doing. This binary <link here> is a portion of a program which obfuscates (not encrypts!) data. Analyze this binary in Ghidra using the same parameters as before. We want to look for opcodes that are changing data, instead of just moving it around. What opcode here actually changes the data it operates on? <XOR>
Challenge 3: Great! You'll want to make sure you understand how all of these opcodes work before we move on. You have observed some data going over a network that you monitor, but the data isn't making any sense. Try to replicate the functionality of this program on this data: <include data here>. What was the original message?
Challenge 4: Here is a portion of a program with a somewhat more complicated obfuscation algorithm. Understand the algorithm, then operate on this data to recover the original message (order of operations is important!) <include data here. Have your code XOR, then ADD, then reverse the byte endianness [i.e. - 5A -> A5]. This will be the first significantly difficult problem, in case DC DarkNet team assigns different numbers of points for each problem>.
Challenge 5: Excellent! Ok, now that you have demonstrated an understanding of assembly, let's add some new techniques. This binary <link here> has not been truncated. The first thing you will likely notice is how much larger it is than the previous binaries. Part of this is due to header and footer bytes that let your computer understand and execute the file, but a lot of it is just infrastructure added by the compiler. You can control what infrastructure gets included to some extent, but all compilers will add in kilobytes or more of overhead to make sure your program operates correctly and avoids common security vulnerabilities. Fortunately, a lot of this information is what Ghidra has been expecting all along, so the analysis should proceed with less input from you than before. Take a look at the Functions list on the left. Ghidra automatically locates memory addresses that the code jumps to, and lists them here. Since we aren't interested in understanding the compiler overhead for now, try to find the obfuscation code from the previous question. What address does it start at? <this will just be the sanitized, complete executable from challenge 4>
Challenge 6: <this should be a program that has a menu and looks for user input to decide what branch to take. One branch should just exit the program, one should print some message to the screen "Welcome"?, and then there should be an option which isn't listed in the menu text, but which does something more interesting like prompt the user for data and then obfuscate it, or print some random data that your program provides a seed for [so everyone would see the same thing]. What needs to be entered by the user to access the hidden function should be unprintable hex that they can't enter with a keyboard.> This binary is a slightly more complicated program. Let's see if we can understand it. Try to find where the interesting code starts. This program has a user interface of sorts, but there is functionality that isn't advertised to the user. What data is displayed to the user when they activate this functionality? <something like "God Mode Unlocked">
Challenge 7: <Now let's have them modify the binary to unlock the functionality. The functionality should be complex enough that it would be time consuming to analyze statically> Having used Ghidra to identify where the hidden functionality is located, let's restore it. For this quest, you'll need to use Ghidra to identify an address, and then use a hex editor to modify that address. In the previous exercise, you found that the hidden functionality requires an unprintable hex value to be entered. There are different ways of dynamically accessing this functionality, but for this exercise, try to modify the hex value to an ASCII value of your choice (always edit a copy of your binary, not the original!). Now when you run the program, you can enter this ASCII value to get the program to execute the "hidden" path. For large programs, you will be able to reverse engineer functionality much more quickly when you use a combination of static (Ghidra) and dynamic (execute the binary, usually in a VM or sandbox) analysis. What is the value printed to the user after the string that indicates the hidden functionality is executing? <doesn't matter. Throw a ton of stuff at it: AES, relying on memory values to compute output, etc.. So long as it is repeatable.>
Challenge 8: Buffer overflow that loses data, require user to brute force the missing/lost byte?
We're probably going to be good with ~10-20 challenges. I think you're on track to have a really well put together quest line that will look great on your resume!
<Feel free to change any of these. I just find it helpful to plan out what I'm going to do so I can understand what my final objective is, and what I need to teach along the way for people to understand it.>

