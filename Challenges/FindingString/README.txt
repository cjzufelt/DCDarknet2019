In this challenge, the user is to decompile a string (c char array, in this case) from the given simple program. The program has been compiled with gcc on an x86-64 bit little-endian system, which will need to be manually entered into Ghidra due to the program being stripped to only its vital bytes.
Answer: My Queen
XOR this with 5A to get 0x17237A0B2F3F3F34
Challenge 1: To use Ghidra, you first need to have a basic understanding of assembly. When you compile a program, your assembler takes your written code and converts it into a series of instructions for a processor. Different processor architectures use different machine instructions (or "opcodes"), which operate on some number of bits, generally to either move or change the bits in some way. Different compilers can have different methods for breaking your code into opcodes, which means that the process of compiling a program is not reversible. What a decompiler like Ghidra does is look at the raw binary of a program, try to determine what processor architecture the code is meant to run on, and then attempt to map the binary in the program to the opcodes of a processor to produce assembly code. Ghidra is a free tool for doing this, which is produced (and used) by the National Security Agency (NSA). To get started, download Ghidra and get it working (this may take some doing!), then create a new project and import <link here> this file. When you import this file, Ghidra likely won't automatically identify the processor, because we've stripped most of the file contents to make the assembly easier to understand. Specify that the Language was compiled for a 32-bit x86 processor by gcc. Ghidra will load the file and display a summary, which we'll cover in more detail in a later exercise. When you double click on the file, or click on the image of Ghidra (looks like a green dragon), it should pull up a new window and ask you if you want to analyze the code. You would! Scroll through all the different options to see what's there, but for now just use the defaults and click Analyze. <Now walk them through some assembly, talking about opcode and operands, and how the command for instance Moves the last operand byte TO the first operand byte> <Find string address?>
Challenge 2: Congrats! You've now used the same tool that the NSA uses, and solved <blah>! Now instead of just finding an address, let's try to use Ghidra to understand what some code is doing. This binary <link here> is a portion of a program which obfuscates (not encrypts!) data. Analyze this binary in Ghidra using the same parameters as before. We want to look for opcodes that are changing data, instead of just moving it around. What opcode here actually changes the data it operates on? <XOR>
Challenge 3: Great! You'll want to make sure you understand how all of these opcodes work before we move on. You have observed some data going over a network that you monitor, but the data isn't making any sense. Try to replicate the functionality of this program on this data: <include data here>. What was the original message?
Challenge 4: Here is a portion of a program with a somewhat more complicated obfuscation algorithm. Understand the algorithm, then operate on this data to recover the original message (order of operations is important!) <include data here. Have your code XOR, then ADD, then reverse the byte endianness [i.e. - 5A -> A5]. This will be the first significantly difficult problem, in case DC DarkNet team assigns different numbers of points for each problem>.
Challenge 5: Excellent! Ok, now that you have demonstrated an understanding of assembly, let's add some new techniques. This binary <link here> has not been truncated. The first thing you will likely notice is how much larger it is than the previous binaries. Part of this is due to header and footer bytes that let your computer understand and execute the file, but a lot of it is just infrastructure added by the compiler. You can control what infrastructure gets included to some extent, but all compilers will add in kilobytes or more of overhead to make sure your program operates correctly and avoids common security vulnerabilities. Fortunately, a lot of this information is what Ghidra has been expecting all along, so the analysis should proceed with less input from you than before. Take a look at the Functions list on the left. Ghidra automatically locates memory addresses that the code jumps to, and lists them here. Since we aren't interested in understanding the compiler overhead for now, try to find the obfuscation code from the previous question. What address does it start at? <this will just be the sanitized, complete executable from challenge 4>
